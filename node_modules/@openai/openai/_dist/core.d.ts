import { Stream } from "./streaming.js";
import { APIError } from "./error.js";
import { type Readable, type Agent, type RequestInfo, type RequestInit, type Response, type HeadersInit } from "./_shims/index.js";
export { type Response };
import { BlobLike } from "./uploads.js";
export { type Uploadable } from "./uploads.js";
export type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;
type PromiseOrValue<T> = T | Promise<T>;
type APIResponseProps = {
  response: Response;
  options: FinalRequestOptions;
  controller: AbortController;
};
type WithRequestID<T> = T extends Array<any> | Response | AbstractPage<any> ? T : T extends Record<string, any> ? T & {
  _request_id?: string | null;
} : T;
/**
 * A subclass of `Promise` providing additional helper methods
 * for interacting with the SDK.
 */ export declare class APIPromise<T> extends Promise<WithRequestID<T>> {
  private responsePromise: any;
  private parseResponse: any;
  private parsedPromise: any;
  constructor(responsePromise: Promise<APIResponseProps>, parseResponse?: (props: APIResponseProps) => PromiseOrValue<WithRequestID<T>>);
  _thenUnwrap<U>(transform: (data: T, props: APIResponseProps) => U): APIPromise<U>;
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import â€¦ from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */ asResponse(): Promise<Response>;
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import â€¦ from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */ withResponse(): Promise<{
    data: T;
    response: Response;
    request_id: string | null | undefined;
  }>;
  private parse: any;
  override then<TResult1 = WithRequestID<T>, TResult2 = never>(onfulfilled?: ((value: WithRequestID<T>) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  override catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<WithRequestID<T> | TResult>;
  override finally(onfinally?: (() => void) | undefined | null): Promise<WithRequestID<T>>;
}
export declare abstract class APIClient {
  baseURL: string;
  maxRetries: number;
  timeout: number;
  httpAgent: Agent | undefined;
  private fetch: any;
  protected idempotencyHeader?: string;
  constructor({}: {
    baseURL: string;
    maxRetries?: number | undefined;
    timeout: number | undefined;
    httpAgent: Agent | undefined;
    fetch: Fetch | undefined;
  });
  protected authHeaders(opts: FinalRequestOptions): Headers;
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */ protected defaultHeaders(opts: FinalRequestOptions): Headers;
  protected abstract defaultQuery(): DefaultQuery | undefined;
  /**
   * Override this to add your own headers validation:
   */ protected validateHeaders(headers: Headers, customHeaders: Headers): void;
  protected defaultIdempotencyKey(): string;
  get<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
  post<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
  patch<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
  put<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
  delete<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp>;
  private methodRequest: any;
  getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(path: string, Page: new(...args: any[]) => PageClass, opts?: RequestOptions<any>): PagePromise<PageClass, Item>;
  private calculateContentLength: any;
  buildRequest<Req>(inputOptions: FinalRequestOptions<Req>, {}?: {
    retryCount?: number;
  }): {
    req: RequestInit;
    url: string;
    timeout: number;
  };
  private buildHeaders: any;
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */ protected prepareOptions(options: FinalRequestOptions): Promise<void>;
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */ protected prepareRequest(request: RequestInit, {}: {
    url: string;
    options: FinalRequestOptions;
  }): Promise<void>;
  protected parseHeaders(headers: HeadersInit | null | undefined): Record<string, string>;
  protected makeStatusError(status: number | undefined, error: Object | undefined, message: string | undefined, headers: Headers | undefined): APIError;
  request<Req, Rsp>(options: PromiseOrValue<FinalRequestOptions<Req>>, remainingRetries?: number | null): APIPromise<Rsp>;
  private makeRequest: any;
  requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(Page: new(...args: ConstructorParameters<typeof AbstractPage>) => PageClass, options: FinalRequestOptions): PagePromise<PageClass, Item>;
  buildURL<Req>(path: string, query: Req | null | undefined): string;
  protected stringifyQuery(query: Record<string, unknown>): string;
  fetchWithTimeout(url: RequestInfo, init: RequestInit | undefined, ms: number, controller: AbortController): Promise<Response>;
  private shouldRetry: any;
  private retryRequest: any;
  private calculateDefaultRetryTimeoutMillis: any;
  private getUserAgent: any;
}
export type PageInfo = {
  url: URL;
} | {
  params: Record<string, unknown> | null;
};
export declare abstract class AbstractPage<Item> implements AsyncIterable<Item> {
  protected options: FinalRequestOptions;
  protected response: Response;
  protected body: unknown;
  constructor(client: APIClient, response: Response, body: unknown, options: FinalRequestOptions);
  /**
   * @deprecated Use nextPageInfo instead
   */ abstract nextPageParams(): Partial<Record<string, unknown>> | null;
  abstract nextPageInfo(): PageInfo | null;
  abstract getPaginatedItems(): Item[];
  hasNextPage(): boolean;
  getNextPage(): Promise<this>;
  iterPages(): AsyncGenerator<this>;
}
/**
 * This subclass of Promise will resolve to an instantiated Page once the request completes.
 *
 * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:
 *
 *    for await (const item of client.items.list()) {
 *      console.log(item)
 *    }
 */ export declare class PagePromise<PageClass extends AbstractPage<Item>, Item = ReturnType<PageClass['getPaginatedItems']>[number]> extends APIPromise<PageClass> implements AsyncIterable<Item> {
  constructor(client: APIClient, request: Promise<APIResponseProps>, Page: new(...args: ConstructorParameters<typeof AbstractPage>) => PageClass);
}
type HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';
export type Headers = Record<string, string | null | undefined>;
export type DefaultQuery = Record<string, string | undefined>;
export type RequestOptions<Req = unknown | Record<string, unknown> | Readable | BlobLike | ArrayBufferView | ArrayBuffer> = {
  method?: HTTPMethod;
  path?: string;
  query?: Req | undefined;
  body?: Req | null | undefined;
  headers?: Headers | undefined;
  maxRetries?: number;
  stream?: boolean | undefined;
  timeout?: number;
  httpAgent?: Agent;
  signal?: AbortSignal | undefined | null;
  idempotencyKey?: string;
  __metadata?: Record<string, unknown>;
  __binaryRequest?: boolean | undefined;
  __binaryResponse?: boolean | undefined;
  __streamClass?: typeof Stream;
};
export type FinalRequestOptions<Req = unknown | Record<string, unknown> | Readable | DataView> = RequestOptions<Req> & {
  method: HTTPMethod;
  path: string;
};
//# sourceMappingURL=core.d.ts.map