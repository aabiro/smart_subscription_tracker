import { ChatCompletionCreateParams, ChatCompletionTool } from "../resources/chat/completions.js";
import { ChatCompletionStreamingToolRunnerParams, ChatCompletionStreamParams, ChatCompletionToolRunnerParams } from "../resources/beta/chat/completions.js";
import { ResponseFormatJSONSchema } from "../resources/shared.js";
import { type ResponseFormatTextJSONSchemaConfig } from "../resources/responses/responses.js";
type AnyChatCompletionCreateParams = ChatCompletionCreateParams | ChatCompletionToolRunnerParams<any> | ChatCompletionStreamingToolRunnerParams<any> | ChatCompletionStreamParams;
export type ExtractParsedContentFromParams<Params extends AnyChatCompletionCreateParams> = Params['response_format'] extends AutoParseableResponseFormat<infer P> ? P : null;
export type AutoParseableResponseFormat<ParsedT> = ResponseFormatJSONSchema & {
  __output: ParsedT;
  $brand: 'auto-parseable-response-format';
  $parseRaw(content: string): ParsedT;
};
export type AutoParseableTextFormat<ParsedT> = ResponseFormatTextJSONSchemaConfig & {
  __output: ParsedT;
  $brand: 'auto-parseable-response-format';
  $parseRaw(content: string): ParsedT;
};
type ToolOptions = {
  name: string;
  arguments: any;
  function?: ((args: any) => any) | undefined;
};
export type AutoParseableTool<OptionsT extends ToolOptions, HasFunction = OptionsT['function'] extends Function ? true : false> = ChatCompletionTool & {
  __arguments: OptionsT['arguments'];
  __name: OptionsT['name'];
  __hasFunction: HasFunction;
  $brand: 'auto-parseable-tool';
  $callback: ((args: OptionsT['arguments']) => any) | undefined;
  $parseRaw(args: string): OptionsT['arguments'];
};
//# sourceMappingURL=parser.d.ts.map